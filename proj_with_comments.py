from math import log, sin, cos, fabs

NUM = 128

#Левый аргумент функции max
#Формальных параметров не имеет
#Работает с value из внешней функции
#Сделано для невозможности изменения 
#значения value в ходе работы функции
def even_lhs(value):
        #1) вычисляется значение знаменателя в логарифме
        #Если данное значение равно нулю - функция
        #возвращает код ошибки, передаваемый в таблицу
        res_value = sin(value + NUM)
        if res_value == 0:
            return f"Error: devision zero"
        #2) вычисляется значение аргумента логарифма
        #Если данное значение равно нулю или меньше нуля 
        #функция возвращает код ошибки, передаваемый в таблицу
        res_value = ((1-NUM) / res_value)
        if res_value < 0:
            return f"Error: log argument < 0"
        elif res_value == 0:
            return f"Error: log argument = 0"
        #3) ошибки не убнаружены - вычисляем значение логарифма
        #возвращаем его
        return log(res_value, 21)

#Правый аргумент функции max
#Формальных параметров не имеет
#Работает с value из внешней функции
#Сделано для невозможности изменения 
#значения value в ходе работы функции
def even_rhs(value):
    #Возвращаем значения правого аргумента функции max
    return fabs(cos(value) / NUM)

#Функция, считающая выражение для чётных номеров
#Внутри содержит две функции, отвечающие за lhs -
#левый и rhs - правый аргументы в функции max
#Принимает значение value - значение из диапазона
def even_max(value):
    #вычисляем значение левого аргумента функции max - функции even_lhs()
    #если данное значение - строка, то это код ошибки - возвращаем данный код
    #если данное значение - число, то передаём его в функцию max вместе с 
    #правым аргументом функции max - функцией even_rhs()
    #возвращаем значение функции max
    lhs = even_lhs(value)
    if isinstance(lhs, str):
        return lhs
    else:
        return max(lhs, even_rhs(value))

#Левый аргумент функции max
#Формальных параметров не имеет
#Работает с value из внешней функции
#Сделано для невозможности изменения 
#значения value в ходе работы функции
def odd_lhs(value):
    #1) вычисляется значение знаменателя в логарифме
    #Если данное значение равно нулю - функция
    #возвращает код ошибки, передаваемый в таблицу
    res_value = cos(value - NUM)
    if res_value == 0:
        return f"Error: devision zero"
    #2) вычисляется значение аргумента логарифма
    #Если данное значение равно нулю или меньше нуля 
    #функция возвращает код ошибки, передаваемый в таблицу
    res_value = ((1-NUM) / res_value)
    if res_value < 0:
        return f"Error: log argument < 0"
    elif res_value == 0:
        return f"Error: log argument = 0"
    #3) ошибки не убнаружены - вычисляем значение логарифма
    #возвращаем его
    return log(res_value, 21)

#Правый аргумент функции max
#Формальных параметров не имеет
#Работает с value из внешней функции
#Сделано для невозможности изменения 
#значения value в ходе работы функции
def odd_rhs(value):
    #Возвращаем значения правого аргумента функции min
    return sin(value) / NUM

#Функция, считающая выражение для нечётных номеров
#Внутри содержит две функции, отвечающие за lhs -
#левый и rhs - правый аргументы в функции max
def odd_min(value):
    #вычисляем значение левого аргумента функции max - функции odd_lhs()
    #если данное значение - строка, то это код ошибки - возвращаем данный код
    #если данное значение - число, то передаём его в функцию max вместе с 
    #правым аргументом функции min - функцией odd_rhs()
    #возвращаем значение функции min
    lhs = odd_lhs(value)
    if isinstance(lhs, str):
        return lhs
    else:
        return min(lhs, odd_rhs(value))

#Функция, формирующая таблицу с итоговыми значениями
#Три формальных параметра
#inin_value - начальное значение диапазона
#fin_cal - конечное значение диапазона
#step - шаг диапазона
def table_former(init_val, fin_val, step):
    #функция нахождения определения количества знаков после запятой
    def dec_placer():
        #если шаг - целочисленный, то значения будут также целочисленными
        #если шаг имеет меньше 5 знаков после запятой - считаем, сколько
        #если шаг имеет больше 5 знаков после запятой - берём пять знаков
        str_step = str(step)
        if step%1 == 0:
            return 0
        elif str_step.find('.') != -1:
            return len(str_step.split('.')[1])
        else:
            return 5

    #1) открытие файла для записи (вторично, проще смотреть таблицу значений)
    with open('result_tab.txt', 'w') as result_tab:
        #2) определение числа знаков после запятой для значений диапазонов
        dec_places = dec_placer()
        
        #Счётчик - номер элемента диапазона
        counter = 1
    
        #3) Определение полей таблицы и их размеров (второй print для вывода в файл)
        print('-'*(54 + dec_places))
        print(f'|{"Number":^10}|{"Value":^{dec_places + 10}}|{"Result":^30}|')
        print('-'*(54 + dec_places))
        print('-'*(54+dec_places), file=result_tab)
        print(f'|{"Number":^10}|{"Value":^{dec_places + 10}}|{"Result":^30}|',
                                                            file=result_tab)
        print('-'*(54+dec_places), file=result_tab)

        #4) построчная обработка таблицы
        #цикл прекращает работу, как только начальное значение (инкриментируемое)
        #становится больше конечного значения диапазона
        #счётчик (номер строки) инкрементируется также
        #если номер строки четен - вызывается функция even_max()
        #если номер строки нечетен - вызывается функция odd_max()
        #полученные данные выводятся print-ом в консоль как предусмотрено в задании
        #сначала номер строки -> затем число из диапазона -> затем значение функции для этого числа
    
        while init_val <= fin_val:
            if (counter%2 == 0):
                result = even_max(init_val)
            else:
                result = odd_min(init_val)
            print(f'|{counter:>10}|{init_val:>{dec_places + 10}.{dec_places}f}|{result:>30}|')
            print(f'|{counter:>10}|{init_val:>{dec_places + 10}.{dec_places}f}|{result:>30}|',
                                                                            file=result_tab)
            counter += 1
            init_val += step 

        print('-'*(54 + dec_places))
        print('-'*(54+dec_places), file=result_tab)

#Функция main() - основная функция программы
#В ней происходит ввод значений для построения диапазона
#В ней же отлавливаются ошибки ввода и происходит вызов
#функции формирования таблицы table_former() от введённых значений
def main():
    #Цикл работает, пока не будут введены верные данныеъ
    #В случае ввода неверных данных выбрасывается исключение 
    #и сообщение о виде ошибки
    while True:    
        try:
            initial = float(input("Input initial value: "))
            final = float(input("Input final value: "))
            if initial >= final:
                raise ValueError("initial value >= final value")
            step = float(input("Input sequence step: "))
            if step == 0:
                raise ValueError("step value = 0")
            break
            
        except Exception as excpt:
            print("Error: " + excpt.args[0], end='\n\n')

    #Данные введены, отрисовывается таблица
    table_former(initial, final, step)

if __name__ == "__main__":
    main()